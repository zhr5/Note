# 01 DDD ：杜绝软件退化的利器
两顶帽子：

在不添加新功能的前提下，重构代码，调整原有程序结构，以适应新功能；
实现新的功能。

# 02 以电商支付功能为例演练 DDD
需求描述:
在用户下单以后，经过下单流程进入付款功能；
通过用户档案获得用户名称、地址等信息；
记录商品及其数量，并汇总付款金额；
保存订单；
通过远程调用支付接口进行支付。

# 04 领域模型是如何指导程序设计的？
贫血模型vs充血模型

# 05 聚合、仓库与工厂：傻傻分不清楚
按照以下思路进行的设计就是聚合：

当创建或更新订单时，在订单对象中填入或更新订单的明细就好了；
当保存订单时，只需要将订单对象作为整体去保存，而不需要关心订单数据是怎么保存的、保存到哪几张表中、是不是有事务，保存数据库的所有细节都封装在了订单对象内部；
当删除订单时，删除订单对象就好了，至于如何删除订单明细，是订单对象内部的实现，外部的程序不需要关注；
当查询或装载订单时，客户程序只需要根据查询语句或 ID 查询订单对象就好了，查询程序会在查询过程中自动地去补填订单对应的订单明细。
聚合体现的是一种整体与部分的关系。正是因为有这样的关系，在操作整体的时候，整体就封装了对部分的操作。但并非所有对象间的关系都有整体与部分的关系，而那些不是整体与部分的关系是不能设计成聚合的。因此，正确地识别聚合关系就变得尤为重要。

## 聚合根——外部访问的唯一入口

DDD 的工厂
DDD 中的工厂，与设计模式中的工厂不是同一个概念，它们是有差别的。在设计模式中，为了避免调用方与被调方的依赖，将被调方设计成一个接口下的多个实现，将这些实现放入工厂中。这样，调用方通过一个 key 值就可以从工厂中获得某个实现类。工厂就负责通过 key 值找到对应的实现类，创建出来，返回给调用方，从而降低了调用方与被调方的耦合度。

而 DDD 中的工厂，与设计模式中的工厂唯一的共同点可能就是，它们都要去做创建对象的工作。

DDD 中的工厂，主要的工作是通过装配，创建领域对象，是领域对象生命周期的起点。譬如，系统要通过 ID 装载一个订单：

这时订单仓库会将这个任务交给订单工厂，订单工厂就会分别调用订单 DAO、订单明细 DAO 和用户 DAO 去进行查询；
然后将得到的订单对象、订单明细对象、用户对象进行装配，即将订单明细对象与用户对象，分别 set 到订单对象的“订单明细”与“用户”属性中；
最后，订单工厂将装配好的订单对象返回给订单仓库。
这些就是 DDD 中工厂要做的事情。

DDD 的仓库
然而，当订单工厂将订单对象返回给订单仓库以后，订单仓库不是简单地将该对象返回给客户程序，它还有一个缓存的功能。在DDD 中“仓库”的概念，就是如果服务器是一个非常强大的服务器，那么我们不需要任何数据库。系统创建的所有领域对象都放在仓库中，当需要这些对象时，通过 ID 到仓库中去获取。

但是，在现实中没有那么强大的仓库，因此仓库在内部实现时，会将领域对象持久化到数据库中。数据库是仓库进行数据持久化的一种内部实现，它也可以有另外一种内部实现，就是将最近反复使用的领域对象放入缓存中。这样，当客户程序通过 ID 去获取某个领域对象时，仓库会通过这个 ID 先到缓存中进行查找：

查找到了，则直接返回，不需要查询数据库；
没有找到，则通知工厂，工厂调用 DAO 去数据库中查询，然后装配成领域对象返回给仓库。
仓库在收到这个领域对象以后，在返回给客户程序的同时，将该对象放到缓存中。

以上是通过 ID 装载订单的过程，那么通过某些条件查询订单的过程又是怎么做呢？查询订单的操作同样是交给订单仓库去完成。

订单仓库会先通过订单 DAO 去查询订单表，但这里是只查询订单表，不做 Join 操作；
订单 DAO 查询了订单表以后，会进行一个分页，将某一页的数据返回给订单仓库；
这时，订单仓库就会将查询结果交给订单工厂，让它去补填其对应的用户与订单明细，完成相应的装配，最终将装配好的订单对象集合返回给仓库。
# 06 限界上下文：冲破微服务设计困局的利器